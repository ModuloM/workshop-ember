<script type="text/x-handlebars" data-template-name="tutorial-app">
    <div id="header">
        <h2>Tutoriel {{view.status}}</h2>
    </div>
    <div class="steps">
        {{#each step in Tuto.STEPS}}
            {{view Tuto.StepView stepBinding=step}}
        {{/each}}
    </div>
</script>

<script type="text/x-handlebars" data-template-name="tutorial-step">
    <div class="step-title" {{action toggleDetail target="view"}}>
        {{unbound step.title}}
        <span class="vline a"></span>
        <span class="picto"></span>
        <span class="vline b"></span>
    </div>
    <div {{bindAttr class=":step-detail :well view.detailIsShown:solShown:solHidden"}}>

        <h4>Explications</h4>
        {{view view.explanationView}}

        <h4>Que manque t'il ?</h4>
        <div class="well">
            {{step.errors}}
        </div>
        <button class="btn btn-success" type="button" {{action toggleSolution target="view"}}>Solution<span class="caret"></span></button>

        <div {{bindAttr class=":solution view.solutionIsShown:solShown:solHidden"}}>
            {{view view.solutionView}}
        </div>
    </div>

</script>

<script type="text/x-handlebars" data-template-name="tutorial-step-empty">
    Pas détail, débrouille toi !
</script>

<script type="text/x-handlebars" data-template-name="tutorial-solution-empty">
    Pas de solution
</script>

<script type="text/x-handlebars" data-template-name="tutorial-step-app">
    <p>L'objectif de cet atelier est d'écrire une application permettant d'afficher, de trier et de rechercher dans des access_logs.</p>

    <p>
        Allez dans le fichier App.js, et créez un objet <code>App</code> de type <code>Ember.Application</code> et précisez que son élement racine est <code>ember-app</code>.
    </p>

    <a href="http://emberjs.com/guides/application" target="_blank">Documentation du concept d'application</a>
    <br />
    <a href="http://emberjs.com/api/classes/Ember.Application.html" target="_blank">API de Ember.Application, cf. rootElement</a>
</script>

<script type="text/x-handlebars" data-template-name="tutorial-solution-app">
App = Ember.Application.create({
    rootElement: '#ember-app'
});
</script>

<script type="text/x-handlebars" data-template-name="tutorial-step-hello">
    <p>L'application Ember maintenant créée, il est temps d'afficher votre premier texte. </p>

    <p>Créez un nouveau template nommé <code>application</code> avec une balise <code>header</code> content le texte <code>Xebia / JS</code>. </p>

    <a href="http://emberjs.com/guides/application/the-application-template" target="_blank">Documentation du template d'application</a>
</script>

<script type="text/x-handlebars" data-template-name="tutorial-solution-hello">
    &lt;script type="text/x-handlebars" data-template-name="application">
    <header>Xebia / JS</header>
    &lt;/script>
</script>



<script type="text/x-handlebars" data-template-name="tutorial-step-ds">
    <p>Il va maintenant être nécessaire de créer une classe pour représenter les logs.
        Pour cela, nous allons utiliser <a href="https://github.com/emberjs/data" target="_blank">Ember-Data</a>, une librairie expérimentale gérant l'aspect persistence des données pour Ember</p>

    <p>La première étape va être de configurer un store&nbsp;: <a href="http://emberjs.com/guides/models/defining-a-store" target="_blank">créer un store</a>.</p>

</script>

<script type="text/x-handlebars" data-template-name="tutorial-solution-ds">
    App.Store = DS.Store.extend({
        revision: 12
    });
</script>

<script type="text/x-handlebars" data-template-name="tutorial-step-model">
    <p>Ensuite, il faut définir une classe <code>App.Log</code>,  avec 5 propriétés de type string&nbsp;:
        <code>host</code>, <code>date</code>, <code>request</code>, <code>useragent</code> et <code>status</code>,
        ainsi qu'une propriété <code>size</code> de type number.</p>

    <a href="http://emberjs.com/guides/models/defining-models" target="_blank">Définition des modèles</a>
</script>

<script type="text/x-handlebars" data-template-name="tutorial-solution-model">
    App.Log = DS.Model.extend({
        host: DS.attr('string'),
        date: DS.attr('string'),
        request: DS.attr('string'),
        status: DS.attr('string'),
        size: DS.attr('number'),
        useragent: DS.attr('string')
    });

</script>

<script type="text/x-handlebars" data-template-name="tutorial-step-list">

    <p>Par convention, sur le chemin <strong>/</strong> Ember rend la route <strong>Index</strong>
        (cf <a target="_blank" href="http://emberjs.com/guides/routing/defining-your-routes/">les conventions sur les routes</a>.
        Vous devez donc maintenant définir une route <code>App.IndexRoute</code>, dont le modèle associé sera la liste des logs renvoyés par le modèle.</p>
    <a target="_blank" href="http://emberjs.com/guides/routing/specifying-a-routes-model/">Pour définir une route (il n'y a pas besoin de définir de router pour l'instant, tout se fait par convention)</a>
    <br />
    <a target="_blank" href="http://emberjs.com/guides/models/finding-models/">Pour récupérer la liste des poneys depuis le modèle</a>
    <p>Nous allons maintenant afficher la liste des logs dans la page.
        Pour cela il faut ajouter une balise <a target="_blank" href="http://emberjs.com/api/classes/Ember.Handlebars.helpers.html#method_outlet"><code>outlet</code></a> au template <code>application</code>,
        <code>outlet</code> qui nous servira de placeholder indiquant où sera insérée le template index.</p>

    <p>Enfin, il faut créer un nouveau template nommé <code>index</code>.
        Par convention, le modèle renvoyé par la route est chargé dans une propriété nommé <code>content</code> dans le controller.
        Ici, la liste des logs est donc accessible dans le template depuis la propriété content.

        Créer un tableau HTML dans une div dont l'id est <code>content</code> avec les colonnes <code>Path</code>, <code>Method</code>, <code>Status</code>, <code>Size</code>, <code>Time</code>.
        &Agrave; l'intérieur de ce tableau, afficher pour l'instant les données <code>status</code>, <code>size</code> et <code>date</code> de chaque log.
    </p>


    <a target="_blank" href="http://emberjs.com/guides/templates/displaying-a-list-of-items/">Affiche une liste d'éléments dans un template</a>

</script>

<script type="text/x-handlebars" data-template-name="tutorial-solution-list">
    App.IndexRoute = Ember.Route.extend({
        model: function () {
            return App.Log.find();
        }
    });

    &lt;script type="text/x-handlebars" data-template-name="application">
    <header>Xebia / JS</header>
    {{outlet}}
    &lt;/script>

    &lt;script type="text/x-handlebars" data-template-name="index">
    <div id="content">
    <table>
        <thead>
        <tr>
            <th>Path</th>
            <th>Method</th>
            <th>Status</th>
            <th>Size</th>
            <th>Time</th>
        </tr>
        </thead>
        <tbody>
        {{#each log in content}}
        <tr>
            <td></td>
            <td></td>
            <td>{{log.status}}</td>
            <td>{{log.size}}</td>
            <td>{{log.date}}</td>
        </tr>
        {{/each}}
        </tbody>
    </table>
    </div>
    &lt;/script>
</script>



<script type="text/x-handlebars" data-template-name="tutorial-step-computed">
    <p>Nous allons maintenant afficher le chemin (path) et la méthode de chaque log.
        Pour cela, nous allons déclarer
        2 propriétés calculées <code>path</code> et <code>method</code> dans la classe <code>App.Log</code>.
        Les <a target="_blank" href="http://emberjs.com/guides/object-model/computed-properties/">propriétés calculées</a>
        sont des propriétés accessibles sur les objets Ember, dont la valeur est dépendante d'autres propriétés du même objet.
    </p>
    <p>La propriété calculée <code>path</code> doit être le chemin présent dans la request.
        La propriété calculée <code>method</code> doit être le verbe HTTP présent dans la request.
        Afficher ensuite ces propriétés dans le tableau des logs.</p>
</script>

<script type="text/x-handlebars" data-template-name="tutorial-solution-computed">

    App.Log = DS.Model.extend({
        host: DS.attr('string'),
        date: DS.attr('string'),
        request: DS.attr('string'),
        status: DS.attr('string'),
        size: DS.attr('number'),
        useragent: DS.attr('string'),

        path: function () {
        var parts = this.get('request').split(' ');
        return parts[1];
        }.property('request'),
        method: function () {
        var parts = this.get('request').split(' ');
        return parts[0];
        }.property('request')
    });

    &lt;script type="text/x-handlebars" data-template-name="index">
    <div id="content">

        <table>
            <thead>
            <tr>
                <th>Path</th>
                <th>Method</th>
                <th>Status</th>
                <th>Size</th>
                <th>Time</th>
            </tr>
            </thead>
            <tbody>
            {{#each log in content}}
            <tr>
                <td>{{log.path}}</td>
                <td>{{log.method}}</td>
                <td>{{log.status}}</td>
                <td>{{log.size}}</td>
                <td>{{log.date}}</td>
            </tr>
            {{/each}}
            </tbody>
        </table>
    </div>
    &lt;/script>
</script>


<script type="text/x-handlebars" data-template-name="tutorial-step-helper">
    <p>Nous allons maintenant créer un
        <a target="_blank" href="http://emberjs.com/guides/templates/writing-helpers/">helper</a>,
        permettant d'afficher la taille du log de façon lisible.</p>
    <p>Ce helper devra renvoyer la taille suffixé de B si la taille est inférieur à 1024, sinon renvoyé la taille divisé par 1024, arrondi à 2 décimales, et suffixé de kB.
    Par exemple, si la taille est 103 le helper renverra <strong>103 B</strong>, si la taille est 3045, le helper renvera <strong>2.97 kB</strong></p>
    <p>Créez le helper <code>size</code> et utilisez la taille dans la liste des logs</p>
</script>

<script type="text/x-handlebars" data-template-name="tutorial-solution-helper">
    Ember.Handlebars.registerBoundHelper('size', function (number) {
        if (number > 1024) {
            return (number / 1024).toFixed(2).toString() + ' kB';
        } else {
            return number.toString() + ' B';
        }
    });

    &lt;script type="text/x-handlebars" data-template-name="index">
    <div id="content">

        <table>
            <thead>
            <tr>
                <th>Path</th>
                <th>Method</th>
                <th>Status</th>
                <th>Size</th>
                <th>Time</th>
            </tr>
            </thead>
            <tbody>
            {{#each log in content}}
            <tr>
                <td>{{log.path}}</td>
                <td>{{log.method}}</td>
                <td>{{log.status}}</td>
                <td>{{size log.size}}</td>
                <td>{{log.date}}</td>
            </tr>
            {{/each}}
            </tbody>
        </table>
    </div>
    &lt;/script>

</script>


<script type="text/x-handlebars" data-template-name="tutorial-step-consultation">
    <p>Nous allons maintenant créer une page de consultation du détail de chaque log.
        Pour cela, nous allons devoir créer une route, un template correspondant à la page de consultation
        et un lien pour atteindre cette page.</p>

    <p> Tout d'abord, nous allons créer une route nommée <code>detail</code>, ayant pour path <code>/log/:log_id</code>. </p>
    <a target="_blank" href="http://emberjs.com/guides/routing/defining-your-routes/">Déclaration d'une route</a>
    <p>Par convention, Ember cherche un template correspondant au nom de la route pour l'insérer dans l'outlet du template <code>application</code>. Par ailleurs, toujours par convention,
        Ember appelle la méthode <code>App.Log.find(log_id)</code> si le paramètre de <code>path</code> se nomme <code>log_id</code>.
        Nous n'avons donc ici pas besoin de définir de route pour charger le modèle.</p>

    <p>Définissez ensuite un template nommé <code>detail</code>, dans lequel vous afficherez le user agent du log choisi.</p>

    <p>Enfin, utilisez le helper <a target="_blank" href="http://emberjs.com/guides/templates/links/">linkTo</a> pour créer un lien vers le détail depuis la liste des logs.
       Attention, un lien <code>linkTo</code> doit toujours prendre en paramètre le même type que le type renvoyé par la méthode <code>model</code> de la route vers laquelle on redirige.
       Ici, on passera donc le log, et pas l'identifiant du log.

    </p>
</script>

<script type="text/x-handlebars" data-template-name="tutorial-solution-consultation">
    App.Router.map(function () {
        this.route('detail', {path: 'log/:log_id'});
    });

    &lt;script type="text/x-handlebars" data-template-name="detail">
        User agent: {{content.useragent}}
    &lt;/script>

    &lt;script type="text/x-handlebars" data-template-name="index">
    <div id="content">

        <table>
            <thead>
            <tr>
                <th>Path</th>
                <th>Method</th>
                <th>Status</th>
                <th>Size</th>
                <th>Time</th>
            </tr>
            </thead>
            <tbody>
            {{#each log in filteredLogs}}
            <tr>
                <td>{{#linkTo detail log}}{{log.path}}{{/linkTo}}</td>
                <td>{{log.method}}</td>
                <td>{{log.status}}</td>
                <td>{{size log.size}}</td>
                <td>{{log.date}}</td>
            </tr>
            {{/each}}
            </tbody>
        </table>
    </div>
    &lt;/script>

</script>


<script type="text/x-handlebars" data-template-name="tutorial-step-home">
    <p>Créez maintenant un lien sur le titre de l'application pour retourner à la home page. Par convention, la home page se nomme <code>index</code>.</p>
</script>

<script type="text/x-handlebars" data-template-name="tutorial-solution-home">
    &lt;script type="text/x-handlebars" data-template-name="application">
    <header>
        {{#linkTo index}}Xebia / JS{{/linkTo}}
    </header>
    {{outlet}}
    &lt;/script>
</script>

<script type="text/x-handlebars" data-template-name="tutorial-step-search">
    <p>Nous allons maintenant créer un champs de recherche permettant de filtrer les résultats affichés.</p>

    <p>Pour cela, il faut tout d'abord insérer dans le template index le champ de recherche. Pour cela nous allons utiliser un helper spécifique <a target="_blank" href="http://emberjs.com/blog/2013/04/21/ember-1-0-rc3.html"><code>input</code></a>.
       Ce helper genere un champs input, qu'il faudra un insérer dans une <code>div</code> dont l'id sera top.
    </p>
    <p>Le helper <code>input</code> permet de préciser le type du champ ainsi que l'attribut dans lequel la valeur sera enregistré.
    Ici nous voulons que le helper soit de type <code>search</code> et qu'il point vers un attribut nommé <code>searchTerm</code></p>

    <p>Nous voulons maintenant que les données soient filtrées au fur et à mesure de la frappe. Le contexte par défaut d'un template étant le controller associé,
    il nous faut ici créer le controller correspondant à la vue index. <a target="_blank" href="http://emberjs.com/guides/routing/defining-your-routes/">Par convention</a>, ce controller sera nommé <code>App.IndexController</code>.</p>
    <p>Pour n'afficher que les valeurs filtrées, au lieu de parcourir <code>content</code> dans le template, nous allons parcourir une propriété calculée déclarée dans le controller que
    nous nommerons <code>filteredLogs</code>.</p>
    <p><code>filteredLogs</code> est une propriété calculée qui dépend de <code>searchTerm</code> et de <code>content</code>. Cependant, pour écouter les modification apportées à content, qui est un tableau, il faut en plus utiliser la notation <a target="_blank" href="http://emberjs.com/guides/object-model/computed-properties-and-aggregate-data/"><code>.@each</code></a></p>

    <p>Vous devez maintenant écrire la propriété calculée <code>filteredLog</code> qui parcours chaque element de <code>content</code> et ne renvoit que ceux dont le path contient le <code>searchTerm</code> si un searchTerm est saisi</p>
</script>

<script type="text/x-handlebars" data-template-name="tutorial-solution-search">
    App.IndexController = Ember.ArrayController.extend({
        searchTerm: '',
        filteredLogs: function () {

            var searchTerm = this.get('searchTerm').trim();

            return this.get('content').filter(function (log) {
                return searchTerm == '' || log.get('path').indexOf(searchTerm) != -1
            });
        }.property('content.@each', 'searchTerm')
    });

    &lt;script type="text/x-handlebars" data-template-name="index">
    <div class="top">
        <div>{{input type="search" value=searchTerm}}</div>
    </div>

    <div id="content">

        <table>
            <thead>
            <tr>
                <th>Path</th>
                <th>Method</th>
                <th>Status</th>
                <th>Size</th>
                <th>Time</th>
            </tr>
            </thead>
            <tbody>
            {{#each log in filteredLogs}}
            <tr>
                <td>{{#linkTo detail log}}{{log.path}}{{/linkTo}}</td>
                <td>{{log.method}}</td>
                <td>{{log.status}}</td>
                <td>{{size log.size}}</td>
                <td>{{log.date}}</td>
            </tr>
            {{/each}}
            </tbody>
        </table>
    </div>
    &lt;/script>
</script>


<script type="text/x-handlebars" data-template-name="tutorial-step-status">
</script>
<script type="text/x-handlebars" data-template-name="tutorial-solution-status">
</script>
<script type="text/x-handlebars" data-template-name="tutorial-step-method">
</script>
<script type="text/x-handlebars" data-template-name="tutorial-solution-method">
</script>
<script type="text/x-handlebars" data-template-name="tutorial-step-empty-list">
</script>
<script type="text/x-handlebars" data-template-name="tutorial-solution-empty-list">
</script>

<!--





<script type="text/x-handlebars" data-template-name="tutorial-step-add">
    <p>Il est maintenant nécessaire de pouvoir ajouter de nouveaux poneys. Pour cela, nous allons créer une route, un controller et un template.</p>

    <p>Tout d'abord, il faut créer la route <code>add</code>, permettant d'arriver sur la page d'ajout.
        Par convention, si aucun chemin n'est spécifié, l'url de la route se déduit de son nom.</p>
    <a target="_blank" href="http://emberjs.com/guides/routing/defining-your-routes/">Rappel sur la création de route</a>

    <p>Nous allons maintenant créer le template <code>add</code> avec un formulaire.
        Ember fournit des composants permettant de gérer le binding sur les formulaires, nous allons donc les utiliser.
        Créer un formulaire avec 4 label et
        4 champs input textfield en utilisant <a target="_blank" href="http://emberjs.com/blog/2013/04/21/ember-1-0-rc3.html">la syntaxe de formulaire de la RC.3</a></p>

    <p>Pour que nos propriétés soient enregistrées dans un objet avant d'être synchronisées par Ember Data,
        il faut créer cet objet au niveau du controller.
        Une solution pour cela est d'indiquer que le modèle correspondant à notre route est un objet simple contenant une propriété id préremplie, par exemple&nbsp;:
    <code>{id: new Date().getTime()}</code>.
        Créez la route <code>App.AddRoute</code> et dans sa méthode modèle, renvoyez l'objet précréé.</p>

    <p>Il ne reste plus qu'à créer un bouton dans le formulaire qui enregistrera effectivement le poney dans le store.
        Pour cela ajoutez un <strong>input HTML  de type submit</strong>
        à votre formulaire, utilisez un helper
        <a target="_blank" href="http://emberjs.com/guides/templates/actions/">action</a>
        pour appeler la méthode <code>savePoney</code>. </p>

    <p>Créez un controller <code>App.AddController</code> héritant de <code>Ember.ObjectController</code>, et créez une méthode <code>savePoney</code> dans celui.
        C'est cette méthode qui est appelée par le bouton.
        Les champs du formulaire sont synchronisés en temps réel au fur et à mesure de la frappe&nbsp;;
        la méthode <code>savePoney</code>
        peut donc se contenter d'enregistrer l'attribut <code>content</code> du controller dans le datastore.
    </p>

    <p>Pour accéder au content du controller, vous pouvez utiliser la méthode <code>this.get('content')</code>.
        Pour enregistrer votre modèle, vous devez utiliser la fonction <code>createRecord</code> de <code>App.Pony</code>, exemple&nbsp;:
        <code>App.Pony.createRecord(this.get('content'));</code>
    </p>

    <p>Enfin, une fois le poney enregistré dans le datastore, on souhaite rediriger vers l'accueil.
        Pour cela, le controller possède une méthode
        <a target="_blank" href="http://emberjs.com/api/classes/Ember.Controller.html#method_transitionToRoute">transitionToRoute</a>
        prenant en paramètre le  nom de la route vers laquelle on désire être redirigé.</p>

</script>
<script type="text/x-handlebars" data-template-name="tutorial-solution-add">
App.Router.map(function () {
    this.route('detail', {path: 'pony/:pony_id'});
    this.route('add');
});

App.AddRoute = Ember.Route.extend({
  model: function () {
    return {id: new Date().getTime()};
  }
});

App.AddController = Ember.ObjectController.extend({
  savePony: function () {
    App.Pony.createRecord(this.get('content'));
    this.transitionToRoute('index');
  }
});

&lt;script type="text/x-handlebars" data-template-name="index">
    \{{#linkTo add}}Add&#123;&#123;/linkTo}}
    <ul>
        \{{#each pony in content}}
        <li>\{{#linkTo detail pony}}\{{pony.name}}\{{/linkTo}}</li>
        \{{/each}}
    </ul>
&lt;/script>


&lt;script type="text/x-handlebars" data-template-name="add">
    <form>
        <label for="firstName">First Name</label>
        \{{input value=firstName}}
        <br />

        <label for="lastName">Last Name</label>
        \{{input value=lastName}}
        <br />

        <label for="color">Color</label>
        \{{input value=color}}
        <br />

        <label for="type">Type</label>
        \{{input value=type}}
        <br />

        &lt;input type="submit" \{{action savePoney}} />

    </form>
&lt;/script>
</script>

<script type="text/x-handlebars" data-template-name="tutorial-step-rest">
    <p>Plutôt que d'utiliser un bouchon, on peut maintenant se brancher directement sur le serveur pour persister les poneys que nous créons.
      Pour cela, changez d'<code>adapter</code> dans le store et utiliser le <a target="_blank" href="http://emberjs.com/guides/models/the-rest-adapter/">le REST adapter</a>.
    </p>

    <p>Par ailleurs, pour synchroniser le store avec le serveur, il est nécessaire de commiter les modifications.
        Pour cela, appelez la méthode <code>this.get('store').commit();</code> juste avant la rédirection dans la méthode <code>savePony</code>
    </p>

</script>
<script type="text/x-handlebars" data-template-name="tutorial-solution-rest">
App.Store = DS.Store.extend({
    revision: 12,
    adapter: 'DS.RESTAdapter'
});

App.AddController = Ember.ObjectController.extend({
  savePony: function () {
    App.Pony.createRecord(this.get('content'));
    this.get('store').commit();
    this.transitionToRoute('index');
  }
});
</script>

-->